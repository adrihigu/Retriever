
class Trajectory{
  ArrayList<PVector> vertices;
  float res = 3;
  float max_angle = radians(3);
  float max_angle_dev = 0.1;
  
  Trajectory(PVector car, PVector ball, PVector end){
    float end_dist = PVector.dist(ball, end);
    float end_res = res/end_dist;
    vertices = new ArrayList<PVector>();
    vertices.add(ball.copy());
    while(PVector.dist(vertices.get(vertices.size() -1), end) >= res){
      PVector last = vertices.get(vertices.size() -1);
      vertices.add(PVector.lerp(last, end, end_res));
    }
    println(PVector.angleBetween(PVector.sub(vertices.get(0), vertices.get(1)), PVector.sub(car, vertices.get(0))));
    float angle_diff = PVector.angleBetween(PVector.sub(vertices.get(0), vertices.get(1)), PVector.sub(car, vertices.get(0)));
    while( angle_diff > radians(15) && PVector.dist(vertices.get(0), car) >= res){
      PVector dir = PVector.sub(vertices.get(0), vertices.get(1));
      PVector dist = PVector.sub(car, vertices.get(0)).normalize();
      float angle_dir = (car.x - vertices.get(0).x) > 0? 1 : -1;
      if(dist.heading() <= PI){
        angle_dir = dir.heading() > dist.heading()?  -1 : 1;
      }else{
        angle_dir = dir.heading() > (dist.heading() + 2*PI)?  -1 : 1;
      }
      float angle = dir.heading() + angle_dir*angle_diff*max_angle_dev;
      PVector next = PVector.fromAngle(angle).mult(sqrt(res)).add(vertices.get(0));
      vertices.add(0,next);
      angle_diff = PVector.angleBetween(PVector.sub(vertices.get(0), vertices.get(1)), PVector.sub(car, vertices.get(0)));
      println(degrees(angle_diff));
      if(vertices.size()>1000) break;
    }
    // while( angle_diff > radians(15) && PVector.dist(vertices.get(0), car) >= res){
    //   PVector dir = PVector.sub(vertices.get(0), vertices.get(1)).normalize();
    //   PVector dist = PVector.sub(car, vertices.get(0)).normalize();
    //   float angle_dir;
    //   if(dist.heading() <= PI){
    //     angle_dir = dir.heading() > dist.heading()?  -1 : 1;
    //   }else{
    //     angle_dir = dir.heading() > (dist.heading() + 2*PI)?  -1 : 1;
    //   }
    //   PVector next = PVector.fromAngle(dir.heading() + angle_diff*max_angle_dev*angle_dir).mult(sqrt(res)).add(vertices.get(0));
    //   vertices.add(0,next);
    //   angle_diff = PVector.angleBetween(PVector.sub(vertices.get(0), vertices.get(1)), PVector.sub(car, vertices.get(0)));
    //   println(degrees(angle_diff));
    //   if(vertices.size()>1000) break;
    // }
    while(PVector.dist(vertices.get(0), car) >= res){
      vertices.add(0, PVector.lerp(vertices.get(0), car, end_res));
    }
    println(degrees((new PVector(-1,-.01)).heading()));
  }

  void display(){
    noFill();
    stroke(color(66, 244, 66));
    strokeWeight(1);
    beginShape();
    for(PVector v : vertices){
      curveVertex(v.x, v.y);
      //print(v);
    };
    endShape();
  }
}
